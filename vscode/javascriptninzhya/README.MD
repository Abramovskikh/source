<h1>JavaScript повсюду</h1>
> Общие представление
JavaScript намного более функционально ориентирован
Функции являются объектами высшего порядка
Замыкания функций
Области видимости
Объектная ориентация на основе прототипов
> Дальнейшие развитие
Комитет ECMAScript преследует цель по внесению
мелких ежегодных изменений в язык
> Трансляторы
Некоторые браузеры неуспевают за циклом обновлений
стандарта JS. Чтобы пользоваться всеми преимуществами
стандарта, можно воспользоваться инструментами,
преобразующими самый передовой код javascript в эквивалентный
код, надлежащим образом действующий в большинстве браузеров.
> Общее представление о браузере
Объектная модель документа (DOM).
События.
API браузера - позволяет получить информацию об устройствах,
сохранять данные локально.
> Нормы передовой практики
Чтобы стать по-настоящему квалифицированным разработчиком
приложений на js, необходимо также освоить наилучшие образцы,
приемы и способы, накопленные в программировании предыдущими поколениями
разработчиков для написания качественного кода.
> Отладка
За последние годы возможности отладки кода js значительно расширились,
благодоря средствам web-разработки. Они предоставляют функциональные 
возможности, в том числе исследование модели DOM, отладка кода JS,
редактирование стилей CSS.
> Тестирование
> Анализ производительности
console.time("operation");
// много инструкций
console.timeEnd("operation");
> Переносимость навыков
HTML, CSS, интерфейс DOM API и JS были стандартизированы. Стал
возможен подход как к веб-сайтам так и к веб-прилложениям. Применяя
браузеры и Node.js, можно разрабатывать практически любой тип приложения.
Настольные приложения. (NW.js and Electron)
Приложения для мобильных устройств. (cordova.apache.org)
Серверные приложения и приложения для встраиваемых устройств.

**Создание страницы в динамическом режиме**
> Общее представление о жизненном цикле веб-приложения
== Начало жизненного цикла ==
Пользователь вводит URL -->
Браузер составляет запрос и посылает серверу -->
Сервер выполняет действия и получает ресурс, посылает его клиенту -->
Браузер обрабатывате код HTML,CSS и JS формирует в итоге страницу -->
Браузер контролируте очередь событий, обрабатывая любые события по очереди -->
Пользователь взаимодействует с элементами страницы -->
Пользователь закрывате вуб-приложение -->
== Конец жизненного цикла ==
*Создание файла: /chapter_02/index.html*
> Стадия создания страницы
Чтобы стало возможным взаимодействие с пользователем или отображение
данного веб-приложения, необходимо сначала создать страницу.
1.Синтаксический анализ HTML-разметки и построение DOM
2.Выполнение кода JS.
> Синтаксический анализ кода HTML и построение DOM
Стадия создания страницы начинается с получения браузером кода HTML
В процессе создания страницы, браузер встретив эламент script приостанавливает
построение модели DOM из кода HTML и начинает выполнение кода JS
> Выполнение кода JavaScript
Браузер предоставляет API через глобальный объект
Объект window является исходным глобальным объектом, через который
становятся доступными все остальные глобальные объекты, переменные и интерфйсы API
РАЗЛИЧАЮТ два типа кода JS: глобальный и код функции
> Обработка событий
> Общее представление
Среда выполнения браузера, действует по принцепу однопоточного выполнения
Во время выпонения кода обработчика остальные события ждут своей очереди
События могут наступить в непредсказуемый момент времени, поэтому их обработка
и вызов функции их обработки происходить АСИНХРОННО
> Регистрация обработчиков событий
Обработчики событий являются функциями, которые требуется выполнять всякий раз,
когда конкретное событие.
Присваивание функции специальным свойствам не рекомендуется, поскольку таким
способом можно зарегистировать только одну функциую.

**Представление о функциях**
Функции относятся к котегории объектов высшего порядка, в JS они интерпритируются
как другие объекты. На них, как на обычные типы данных, можно ссылаться с помощью переменных
> Главное отличие JS как языка функционального программирования
Функция является основным модульным исполняемым блоком
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Действия можно выполнить над функциями:
 создавать с помощью литералов: foo() {}
 присваивать переменным, элемениам массива и свойствам других объектов
      var foo = function() {};
      arr.push(function(){});
      o.foo = function() {};
 передавать в качестве аргументов другим функциям
      function f(dataF) {dataF()} f(function(){});
 возвращать в качестве значений из других функций
      function foo() { return function() {} }
 наделять свойствами, которые можно динамически создавать и присваивать им значения
      var foo = function() {};
      foo.variable = "hello";
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
> Функции обратного вызова
Функция устанавливается для последующего обратного ее вызова из какого-нибудь друго кода
в подходящий момент выполнения
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**Сортировка путем сравнения**
<p>array.sort(function(value1, value2){ return value1 - value2; });</p>
<p>Функциональный подход позволяет создать функцию как самостоятельную сущность
и передать ее в качестве аогумента методу</p>

**Особенности применения функций в качестве объектов**
<p>Ничего не мешает добавить свойства к функциям</p>
<p>С помощью этого свойства появляется две возможности: </p>
<p>сохранение функций в коллекции (присваивание ID)</p>
<p>запоминание (кэширование предыдущего ответа для его возврата без расчетов)</p>

**Определение функций**
<p>⏺ Объявления функций и функциональные выражения</p>
<code>function myFun() { return 1; }</code>
<p>⏺ Стрелочные функции (лямбда-функция)</p>
<code>myArg => myArg * 2</code>
<p>⏺ Конструкторы функций</p>
<code>new Function('a', 'b', 'return a + b')</code>
<p>⏺ Функции-генераторы</p>
<code>function* myGen() { yield 1; }</code>

**Аргументы и параметры функций**
